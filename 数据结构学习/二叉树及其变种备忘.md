

代码放到个人仓库了，在这个包下pers.fw.data_structure：https://github.com/Chris-Altair/F-world.git

# 一、二叉树

二叉树（**Binary Tree**）是个比较基础的概念，很少直接使用二叉树，实际都是使用各种二叉树的扩展，如二叉搜索树、AVL树、红黑树等。

## 1.基本概念

**度（degree）**：节点子树的个数

**叶子节点（leaf）**：度为 0 的节点

**非叶子节点**：度不为 0 的节点

**节点的深度（depth）**：从根节点到当前节点的唯一路径上的节点总数

**节点的高度（height）**：从当前节点到最远叶子节点的路径上的节点总数

**树的深度（树的高度）**：所有节点深度中的最大值

**真二叉树（Proper Binary Tree）**：所有节点的度都要么为 0，要么为 2

**满二叉树（Full Binary Tree）**：最后一层的节点度为0，其他节点度为2

**完全二叉树（Complete Binary Tree）**：叶子节点只会出现最后 2 层，且最后 1 层的叶子结点都靠左对齐

**二叉平衡树（AVL树）**：左右子树的高度差<=1，并且左右子树也是二叉平衡树

## 2.常用遍历

### ①深度优先遍历（DFS）

前序遍历、中序遍历、后序遍历可以使用**递归**很简单的实现，若不使用递归可利用**栈**的先进后出的特性实现：时间复杂度和空间复杂度都是**O(n)**

ps: 遍历除了上述方法外，还有一种更高级的算法：**morris算法**，时间复杂度为O(N)，空间复杂度为O(1) 

1. 前序遍历： **根节点**、前序遍历**左子树**、前序遍历**右子树**
2. 中序遍历： 中序遍历**左子树**、**根节点**、中序遍历**右子树**
3. 后序遍历： 后序遍历**左子树**、后序遍历**右子树**、**根节点**

### ②广度优先搜索（BFS）

层序遍历（很重要）： 从上到下、从左到右依次访问每一个节点

层序遍历可以通过**队列**实现：时间复杂度和空间复杂度都是**O(n)**

真二叉树、满二叉树、完全二叉树、计算二叉树的高度等都可以通过层序遍历判断，所以层序遍历的实现一定要记住

------

# 二、二叉搜索树

我们都知道对于有序集合的查找可以使用**二分查找**方式能以O(log n)的时间复杂度完成搜索，但这只适用于静态不变的有序列表，因为如果要修改元素，需要不断地对列表重新排序，并且添加、删除的平均复杂度为O(n)；那有没有方法能避免重新排序，又能兼顾保证搜索、添加和删除呢？答案就是二叉搜索树

## 1.基本概念

二叉搜索树（**Binary Search Tree**，又名二叉排序树）是满足以下条件的二叉树：

- 根节点比任意左子树的节点大，比任意右子树的小
- 任意子树也都是二叉搜索树

## 2.常用操作

二叉搜索树的插入、删除、搜索都是O(log n)级别的，很适合用于动态集合的查询

1. 插入：很简单，即从根节点判断，比根节点小，跟右节点比较，否则跟左节点比较，重复这些过程，直到节点为空
2. 查找：从根节点一路往下找，比根节点小就向右子树找，比根节点大就像左子树找
3. 删除：稍微复杂点，先找到该节点，然后根据节点的度，分情况处理；设要删除的节点为node：
   - 度=2，找到node的左子树最大或右子树最小的节点s(其实就是中序遍历前/后节点，若node的度=2，则前/后节点的度只能为0或1)，用s的值替代node的值，然后删除s
   - 度=1：删除node，并将node的子树接上去
   - 度=0：叶子节点直接删

前面说了二叉搜索树的优点，那它有什么问题呢？再极端情况下，二叉树会变成单链表，这种时候搜索的时间复杂度就变成O(n)了，因此为了保证二叉搜索树的搜索效率的平衡，所以就有了二叉平衡树的概念。

# 三、二叉平衡树--待补充

# 四、红黑树--待补充

参考：

[1]: https://www.cnblogs.com/kalton/p/13689985.html	"深入理解二叉树"

