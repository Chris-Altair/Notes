主要记录些个人实际使用设计模式的一些感想

设计模式大概分为创建型、结构型、行为型，后二者更有趣些。

### 1.代理模式

主要是在不修改原有类的前提下，增强该类某些方法的功能，比如原有个调三方接口的工具，我增加一个统计调用时间的功能，就可以使用代理模式，就相当于用代理类包了一层。

代理分为静态代理和动态代理，静态代理偏向于设计模式层面，需要为每个类都建立代理类

动态代理则是动态生成代理类，一般使用java自带的代理功能（只能代理接口）和cglib（具体可看我写的cglib学习）

我个人觉得尴尬的地方在于有时引入代理模式不一定使更简单，反而使其变得更复杂了，有时2行代码就能解决的问题，用个代理还多个类，而且代理类也不好复用，设计一个抽象的"代理模板"也没什么必要，因为代理基本上都是个性化的需求，别告诉我你还要再抽象个代理策略（把个性化的需求弄成策略那种），这就是典型的简单问题复杂化；想来想去可能写lib会用到多一些，平常也可以用，但必要性不是很大。

### 2.装饰者模式

代理模式的弊端在于只能增强一次方法，如果需要给方法增强多个功能，甚至各个功能的顺序可以自由调整，代理就不适用了，这时候就应该用装饰者模式，这个模式其实很有意思，而且比代理模式更实用一些。

大概结构：

一般需要建一个抽象装饰者继承原类，并且内部有个指向原类的引用，和一个或多个的装饰方法，多个装饰者需要继承该抽象装饰者，调用父类的构造函数和装饰方法，大概下面代码的意思，最典型的应用是java各种输入输出流（ps：我一直觉得流这东西用起来太”底层“了，不像一个高级工具）

实际使用大概是这种方式

```java
new Test1Wrapper(new Test2Wrapper(new Test3Wrapper())).executeTask(task)
```

装饰者简单结构

```java
public abstract class AbstractTaskMQConsumerWrapper extends AbstractTaskMQConsumer {
    private AbstractTaskMQConsumer wrapper;

    public AbstractTaskMQConsumerWrapper(AbstractTaskMQConsumer wrapper) {
        this.wrapper = wrapper;
    }

    @Override
    public void executeTask(TaskPojo task) {
        wrapper.executeTask(task);
    }
}
@Slf4j
public class TestWrapper extends AbstractTaskMQConsumerWrapper {

    public TestWrapper(AbstractTaskMQConsumer wrapper) {
        super(wrapper);
    }

    @Override
    public void executeTask(TaskPojo task) {
        final long beginTime = System.currentTimeMillis();
        super.executeTask(task);
        final long endTime = System.currentTimeMillis();
        log.info("consumer总耗时:{}ms", (endTime - beginTime));
    }
}
```

### 3.模板模式

这估计是我使用了最多的设计模式吧，基本上一些逻辑结构固定，但具体细节不同的都可以使用这种模式，

以我最近的使用举例，有个mq任务消费者，用来处理各种task，不同task处理逻辑不同，但前置的mq接受消息，切换数据库，设置MDC，打印日志等都相同，就很适合将任务处理方法弄成抽象方法，做成模板模式；

还有上家公司弄的数据抽取，抽取的大体逻辑都是固定的，只是要抽取的数据不同，存的表不同。



