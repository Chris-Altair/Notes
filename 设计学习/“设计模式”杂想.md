[TOC]



## 一、我们追求的到底是什么？

我们追求是**整洁、易读、高扩展性**即优雅的代码，而不是某种设计模式。

在我看来，现在所流传的设计模式，仅仅是前辈根据他们的各自需求开发经验所总结的**满足特定场景的最精简、最抽象的一种结构**，仅仅是一种结构、或者说模式，是**“术”**的一种，没必要把它强行推到**“道”**的层面。

例如我在我之前开发的产品中根据实际业务需求，设计了一套通用的主子列表开发模板，使得后续产品中的所有主子列表都可以按照这种模板开发，这其实就是一种设计模式。

不少人学习设计模式可能陷入了一种**误区**：学了某种模式，然后不考虑实际，什么场景都想拿来用，然后发现**束手束脚**，就认为这东西没用。这就是典型的拿着锤子看什么都是钉子，是没有真正理解为什么会存在该模式？该模式到底解决了什么问题？引入该模式会产生什么样的好处、又会引入什么麻烦？（哪怕是潜在的）

所以我认为要写出真正优雅的代码，一定得建立在**真正理解需求**上。这事实上很难，就国内这种偏向把人作为螺丝钉的情况、开发人员的频繁流转等，再加上产品、客户、老板可能自己都没理解真正的需求是什么，以及预估未来可能出现的需求变化也绝非易事；种种原因导致我们客观上很难把代码写好。

对于上述现状，就我个人感觉，不少项目代码质量管理上可能有意或者潜意识地采取这种做法：即不要玩什么花活，把变量的命名保证望文生义、固定的常量统一抽取等等，简而言之，保证基本的代码规范、保证鲁棒性（是叫这个？）即可。这样即便需求变化，每次修改成本也不大；看起来挺好，但时间一长再加上研发人员水平参差不齐，慢慢也就失控成屎山了，所以一般业务迭代上会加上研发人员不定期重构优化的技术需求，以一定程度上缓解屎山越来越大的情况。确实是个很符合实际的举措，从商业角度十分正确，但怎么说呢，从大环境上考虑，真给我一种浓浓的囚徒困境的感觉啊。。。

## 二、为什么真正理解需求对代码设计那么重要？

我们很容易就能发现，一般框架、工具类的代码都是很优雅的，当然一般写这种基础设施的人水平都很高这是一方面，但另一方面比如我现在写一个json解析器时，我其实不止是一个工具的开发人员，我其实已经隐含着我已经很了解一个json解析器应该具备什么功能这一点，并且我很清楚未来功能上基本不会有变化；所以我其实是作为我很了解一个json解析器所应该提供的功能的角色进行研发，我几乎不用考虑未来的变化，定义好对外提供的功能接口，对于内部的设计我有种非常高的自由性，所以我在开发的过程前或中可以不断思考怎么设计让代码更精简、性能更好，慢慢就会逐渐摸索出对于当前自己的最好的一套设计（当然未来你也可能发现有更好的方式）

实际需求开发中，我遇到的主子列表设计可能更符合这种场景，因为既满足业务相对固定（也不算太复杂，一个列表能有啥大变化？）、又满足通用性（作为一种模式，其他研发照着我抄就行，节省大家时间以去做更重要的事情）

```
简单描述下吧：一个订单底下会关联多个子单，每个子单对应用户所买的商品信息（1：*），那么现在我进到列表，我能直接看到订单，也能看到订单下的子单（比如一个订单下有3个子单)，如果一个订单的子单过多超过5条，那就只展示5条，下面有下拉，点击可以展示之后的子单。
前端传一个query作为搜索参数，这个query是作为搜索的参数，我是把它作为充血模型考虑的（按照DDD的思想，他是有行为的，好处在于更易理解，而且也避免把方法全堆到service里的窘境），那么我把只有他会使用的固定的常量作为接口变量封装到类里，它也提供了一些方法用于判断这些字段是安装精确还是模糊搜索。
然后搜索条件大概可以分为两类，一个是主单维度的搜索，一个是子单维度的搜索，建造一个条件factory，用query分别构造出主、子条件，为什么要分成两类呢？因为如果条件如果没有子表相关的条件，那么构造主表相关的sql就可以减少连表情况，提升查询效率
根据是否查询子单调用页面返回factory的不同方法，先查主单（这里可通过先查id连自己减少分页开销），根据主单id和子条件group by差主单对应的子单数，这样子单分为两种，数量>5的使用聚合函数只查前5条，小于5的直接查。这样就避免了循环调用sql的开销，子单搜索条件通过主单id批量查，命中索引，很快
然后再factory内转换数据。
```

上述情况，就是建立在我们真正理解需求的前提下的设计。那么，如果在没充分理解需求或者没有预料到需求的变化，而盲目的使用设计模式会带来什么后果呢？

```
也是实际碰到的场景，当时我在做国外物流对接，这里是对接获取物流单号、获取面单接口，正常的接口都是获取物流单号拿到3方的物流单号，然后根据物流单号去查面单，但三方物流没有统一的标准，各自实现的千变万化不按套路啊，这个物流面单需要用到单号和渠道，渠道是获取单号用的，这是两个方法，然后又使用了factory和adapter包装了好几层，我根本就没法修改获取面单的参数，因为继承了统一的接口，我总不能把几百个物流都改一遍吧，而且参数也根本传不到这个接口，因为中间有很多次嵌套，所以要怎么办呢？我只能采取邪道的做法，物流实体里封装一个ThreadLocal，因为唯一能保证的是这两个方法的调用都在一个线程里，获取单号把渠道存到线程副本里，获取运单取出再移除。
```

说实话，其实人家设计的挺好的，但他没考虑到物流三方的接口套路太深，这就导致当需求发生变化时，他封装的越“好”，我要修改就越麻烦，甚至只能通过各种奇怪甚至诡异的方式小心地避开这些条条框框进行修改。

所以，由上可见：**如果要设计出真正好的代码，我们必须去真正理解需求。**我们要明白我们面临的需求到底是要解决什么问题？这个需求能否真正解决这个问题？这个需求未来有哪些地方可能会有变化、那些地方不会变等等...我们必须要和产品、客户去沟通清楚，要不然你认为不会变的地方结果最后真的发生了变化（等着加班吧，少年），或者你认为会变的地方结果万年不变（白白设计了一套，徒增复杂度），这些欠下的债，早晚会有人还。

## 三、那么如何去理解需求呢？

其实这个说简单也简单，说复杂也复杂：要主动地、深入地、全面地思考需求，要**主动**跟产品或者客户沟通需求，明确是否合理、如果合理的话，要明确这个需求未来的大致有哪些方向上的变化，尽可能明确**变化**与**不变（说实话，产品说不变的地方，不要太相信，最好仔细考虑考虑）**的点。

上面搞清楚之后，不断给自己提出问题、解决问题，设计相应的**模型**，针对不变的地方进行封装，针对可能变化的地方进行扩展，要不断仔细思考满足模型的**最小且完备**的设计，并且也要注意避免过度设计，要保留一定程度上的鲁棒性（毕竟谁都不能预测未来变化），然后你会发现你的设计可能就是某种设计模式，也可能不是（那就说明你自己创造了新的设计模式），所以说设计模式不关键，关键在于你的理解、你的思考。

感觉是不是说的有点玄？举个例子吧

```
之前有个需求采购建议，就是要针对订单的销量情况和库存情况，对货品+仓库维度计算出相应的活跃度（如爆款、稳定之类的），再根据活跃度找到对应的策略，再根据系统设置的相关公式，生成对应的采购建议数据；麻烦的点在于活跃度和策略自由性很高，用户可以启用、也可以禁用，公式也可以调整，并且这些调整都要触发相关数据的更新。

拿到需求文档后，我首先得思考这个需求是否合理，这个需求生成的这些数据要做什么用（作为采购单、采购计划的来源、客户也可以查看数据便于分析），我慢慢就发现这个活跃度很关键，产品提供了几个固定的活跃度，统一启用或者禁用，那么就要明确变与不变，比如这个活跃度优先级未来是否会支持用户自己设置？未来是否会加活跃度？梳理出相关的问题，跟产品沟通...
需求都明确后，开始设计，不同活跃度具有共同的行为，是否可以抽取个活跃度模板？活跃度和策略要怎么封装，各种量计算方法是否可以统一抽取到某个helper类中？为了提高效率，是否可以定制化各种操作的更新方式使其操纵数据最小等待...
```

你看经过不断地提出问题、解决问题，不断地思考，我们就会慢慢摸索出一个复杂需求的较优代码结构，然后在实际开发过程中也可以不断调整优化。

## 四、所以如何进行代码设计？

怎么说呢，这块其实我感觉没啥可说的，软件设计那么多原则，各种经典书籍《代码整洁之道》、《重构》都说的很全面了，网上相关资料也多的是，不复述了。不断学习、思考、然后在实际开发逐渐去积累经验，慢慢感悟吧。

需要提一点，**性能**和**可读性**有时是会存在一定冲突的（例如你是先把所需的数据都查出来在操作，还是按逻辑分成多步操作），这时候就得看你的实际需要和各种方式的实际差异对比了，牢记没有**银弹**。

## 五、个人对常用设计模式的理解

设计模式如果你仔细观察，其实本质上是各种**软件设计原则**的体现。例如迭代器、工厂等就体现了单一权责。

还有很多模式其实源于相同的实现，例如通过类内添加接口成员将具体逻辑委派到接口的具体实现者，如：策略、代理、观察者等等。

所以说死记硬背各种设计模式是没任何意义的，不过是软件设计原则在各种场景下的一种实践罢了。

牢记一句话：**没有什么加一层解决不了的，如果有那再加一层。**

有些模式某种程度上可以算是编程语言表达力缺失的一种体现，有很多模式在其他语言中会以语法糖的形式存在，然而在java你还得自己写...

设计模式大概分为创建型、结构型、行为型。

### 1.创建型

#### ①工厂模式

开始学习工厂模式千万不要去管什么抽象工厂怎么实现啊、怎么包装啊，这绝对是个歧途，你会陷入各种复杂的细节中迷失，而忘记了你的本来目的是什么。

工厂模式的本质在于**将构造复杂对象的逻辑从原有方法中抽离出来使其作为一个单独的逻辑整体（Factory）**，只要把握清楚这点，我觉得就算学明白了。

### 2.结构型

#### ①适配器模式

“适配”顾名思义，其实主要为了是解决接口兼容性问题，通常是原接口的参数结构跟我实际提供的不一致，所以需要加了一层适配层，在这个适配层将数据格式转换为原接口支持的数据格式，这样就能使用原接口了。

```java
class Service {
    void method(data)
}

/**适配器模式本身有不少变种，这里展示最简单、也是最核心的一种*/
class ServiceAdapter {
    Service service;
    void specialMethod(SpecialData) {
        data = convert(SpecialData);
        service.method(data);
    }
}
```

好处在于我可以将与实际业务无关的数据转换代码从业务代码中脱离出来（放到适配层），保证**单一职责**。

当然你可以说我直接改原有接口就行了，如果这个接口很多人都在用那岂不是很多地方都得改；还有些情况例如第三方sdk你是没法改的。

你也可能说数据转换我直接放到外面的业务方法不也可以吗？还省的新建一个类。这就得根据实际情况讨论了，毕竟软件设计没有**银弹**，对于一些简单情况，这么做非常正确，但对于数据转换比较复杂、还可能涉及各种数据的查询、各种接口的调用，那这部分逻辑都堆到业务代码上就严重干扰了业务逻辑的清晰性，这种情况就得抽出去

#### ②代理模式

代理模式的优点主要是在不修改原有类或者也可能无法改变（第三方sdk）的前提下，增强该类某些方法的功能。

代理模式从本质上讲在于抽出了一个新的代理层（**没有什么是加一层解决不了的，如果解决不了，再加一层**），该代理层与原服务具有相同的行为与结构，并且可以根据需要扩展功能。 

实现上为了保证新的代理类对原类的兼容性，一般原类和代理类都会继承相同的接口，如下代码ProxyService也继承了Service，那ProxyService就可以当成Service使用，保证了TargetService和ProxyService结构的一致性。

```java
interface Service {
    void method();
}
class TargetService implements Service {
    void method(){}
}
//代理类也实现同样接口
class ProxyService implements Service {
    TargetService service; 
    void method(){
        //相关增强逻辑
        service.method();
        //相关增强逻辑
    }
}
```

实际使用上一般写基础设施、还有就是包装第三方sdk的功能会用到。

代理分为静态代理和动态代理：

- 静态代理偏向于设计模式层面，需要为每个类都建立代理类
- 动态代理则是动态生成代理类，一般使用java自带的代理功能（只能代理接口）和cglib（具体可看我写的cglib学习）

#### ③装饰者模式

代理模式的弊端在于只能增强一次方法，如果需要给方法增强多个功能，甚至各个功能的顺序可以自由调整，代理就不适用了，这时候就最好用装饰者模式，这个模式有点复杂。

大概结构：

一般需要建一个抽象装饰者继承原类，并且内部有个指向原类的引用，和一个或多个的装饰方法，多个装饰者需要继承该抽象装饰者，调用父类的构造函数和装饰方法，大概下面代码的意思，最典型的应用是java各种输入输出流（ps：我一直觉得流这东西用起来太”底层“了，不像一个高级工具）

实际使用大概是这种方式（实际调用顺序是从外往里调用）

```java
new Test1Wrapper(new Test2Wrapper(new Test3Wrapper())).executeTask(task)
```

装饰者简单结构

```java
public abstract class AbstractTaskMQConsumerWrapper extends AbstractTaskMQConsumer {
    private AbstractTaskMQConsumer wrapper;

    public AbstractTaskMQConsumerWrapper(AbstractTaskMQConsumer wrapper) {
        this.wrapper = wrapper;
    }

    @Override
    public void executeTask(TaskPojo task) {
        wrapper.executeTask(task);
    }
}
@Slf4j
public class TestWrapper extends AbstractTaskMQConsumerWrapper {

    public TestWrapper(AbstractTaskMQConsumer wrapper) {
        super(wrapper);
    }

    @Override
    public void executeTask(TaskPojo task) {
        final long beginTime = System.currentTimeMillis();
        super.executeTask(task);
        final long endTime = System.currentTimeMillis();
        log.info("consumer总耗时:{}ms", (endTime - beginTime));
    }
}
```

### 3.行为型

#### ①模板方法模式

如果一类功能逻辑可以抽离出**固定顺序的步骤**，并且该类下具体步骤实现各不相同，那么就可以考虑模板模式。

```java
//各步骤逻辑交由子类实现
abstract class Template {
    void method() {
        step1();
        step2();
        step3();
    }
    abstract void step1();
    abstract void step2();
    abstract void step3();
}
```

这估计是我使用了最多的设计模式吧，基本上一些逻辑结构固定，但具体细节不同的都可以使用这种模式。

记得前段时间，有个mq任务消费者，用来处理各种task，不同task处理逻辑不同，但前置的mq接受消息，切换数据库，设置MDC，打印日志等都相同，就很适合将任务处理方法弄成抽象方法，做成模板模式；

还有上家公司弄的数据抽取，抽取的大体逻辑都是固定的，只是要抽取的数据不同，存的表不同。

最近也碰到了计算及配置商品活跃度的也可以使用类似模板模式（**虽然严格来说我觉得更像是抽象继承以及策略**）

以活跃度枚举为key，活跃度数据及策略数据为value，对活跃度的行为进行抽象。

#### ②观察者模式

 又名发布订阅模式，其实就是发布者在事件发生时通知多个订阅了该发布者对象的其他对象（订阅者）。 

说实话个人很少用，因为一般类似场景都直接上消息队列了，当然你要造轮子的话另当别论。

```java
interface Subscriber {
    //由具体订阅者自己实现接受事件后的处理逻辑
    void update(event);
}
class ASubscriber implements Subscriber {
    void update(event){...}
}
class Publisher {
    //一个订阅者接口集合
    Collection<Subscriber> subscribers;
    void notify(event) {
 	    //通知所有订阅者
        for(Subscriber subscriber:subscribers) {
            subscriber.update(event)
        }
    }
}
```

#### ③迭代器模式

与其说是一种模式，更像是一种思想。

迭代器模式提供了集合元素的一种遍历模式，其本质在于**将集合遍历的策略从集合本身抽离出**（你看，很多设计模式本质都是**抽象出一个新的层级**）

只是大多数情况下，我们遍历一个容器的元素只按一种就行了，例如list遍历；但对于一些复杂的数据结构，例如二叉树啊、各种树啊，什么先序遍历、后序遍历啊，有不同的遍历方式，这种情况下迭代器模式就很适用。当然通常我们很少去自己写数据容器，因为java各种集合都已经实现了，所以一般情况下当你想造一些数据结构的轮子时或者你需要**定制各种各样的遍历逻辑**时，才会用到（for-remove这种另算）。

```java
//最简单的一种，当然可以有各种变种，例如再加上向前遍历的
interface Iterator<E> {
    //迭代器需要知道迭代的进度
    boolean hasNext();
    E next();
}
interface ICollection {
    //实际可能会创建多种迭代器
    Iterator createIterator();
}
class Collection implements ICollection {
    //具体迭代器可以作为内部类实现，也可以直接放到外面
    Iterator createIterator(){}
}
```

#### ④访问者模式

与其说是一种模式，我还是觉得更像是一种思想。

访问者模式本质上在于将**集合遍历中的元素处理逻辑从遍历代码中抽象出来**，要把握本质，具体实现不重要，硬要说大概有两种实现：

（1）集合中的元素均为同类元素List<T>，这种只需要建一个统一的visitor即可

```java
interface Visitor {
    void visit(Node node);
}

class A {
    //其实有点接近函数式的思想，方法的参数visitor本质上是一个处理函数
    void method(List<Node> list, Visitor visitor) {
        for(Node node: list) {
    		visitor.visit(node);
		}
    }
}

```

（2）集合中的元素存在多种子类List<? extends T>，每种子类型又需要不同的处理，这种就需要将visit的逻辑放到具体元素中实现了（因为无法判断具体类型）

```java
interface Node {
    //具体元素来选择调用Visitor的哪一个方法
    void accept(Visitor v);
}
class NodeA implements Node {
    void accept(Visitor v) {
        v.visitA(v);
    }
}
class NodeB implements Node {
    void accept(Visitor v) {
        v.visitB(v);
    }
}

interface Visitor {
    void visitA(NodeA node);
    void visitB(NodeB node);
}

class A {
    void method(List list, Visitor visitor) {
        for(Node node: list) {
            //说白了就是因为visitor识别不了具体的元素类型，所以必须在元素内判断
            node.accept(visitor);
            //上述操作的优点说白了其实就是取代了类型的if判断
            //if(node instanceof NodeA)
            //    visitor.visitA(node)
            // ...
		}
    }
}
```

#### ⑤策略模式

又是一种通过对象内添加接口成员将具体逻辑委派到接口的具体实现者，其实没啥可说的。

本质就是将具体的不同情况的不同处理逻辑，抽象成一个“策略”，具体处理逻辑放到具体策略的实现者实现。

```java
//抽象出一个策略层
interface Strategy {
    void method();
}
class Context {
    Strategy strategy;
    //设置具体策略
    void setStrategy(Strategy strategy){}
    //执行具体策略
    void doSomething(){
        strategy.method();
    }
}
```

最近弄了个通知报文转换，这个模式很符合我的需求：我需要根据不同的接口码，将不同的请求转成符合不同的发送给下游的参数

```java
//INoticeSourceBody和INoticeTragetBody用来标识参数，实现统一接受
interface NoticeTransferStrategy<T extends INoticeSourceBody, R extends INoticeTragetBody> {
    T convert(String json);
    R transfer(T t, NoticeMessageHead head)
}

class NoticeStrategyContext {
    public NoticeTransferStrategy getStrategy(InterfaceCode interfaceCode) {
        //switch获取策略
    }
}

// 业务处理方法
String dealNotice(...) {
    ...
    NoticeTransferStrategy strategy = noticeStrategyContext.getStrategy(interfaceCode);
    INoticeSourceBody source = strategy.convert(json);
    INoticeTragetBody target = strategy.transfer(source);
    ...
}
```

