## 一、我们追求的到底是什么？

我们追求是**整洁、易读、高扩展性**即优雅的代码，而不是某种设计模式。

在我看来，现在所流传的设计模式，仅仅是前辈根据他们的各自需求开发经验所总结的**满足特定场景的最精简、最抽象的一种结构**，仅仅是一种结构、或者说模式，是**“术”**的一种，没必要把它强行推到**“道”**的层面。

例如我在我之前开发的产品中根据实际业务需求，设计了一套通用的主子列表开发模板，使得后续产品中的所有主子列表都可以按照这种模板开发，这其实就是一种设计模式。

不少人学习设计模式可能陷入了一种**误区**：学了某种模式，然后不考虑实际，什么场景都想拿来用，然后发现**束手束脚**，就认为这东西没用。这就是典型的拿着锤子看什么都是钉子，是没有真正理解为什么会存在该模式？该模式到底解决了什么问题？引入该模式会产生什么样的好处、又会引入什么麻烦？（哪怕是潜在的）

所以我认为要写出真正优雅的代码，一定得建立在**真正理解需求**上。这事实上很难，就国内这种偏向把人作为螺丝钉的情况、开发人员的频繁流转等，再加上产品、客户、老板可能自己都没理解真正的需求是什么，以及预估未来可能出现的需求变化也绝非易事；种种原因导致我们客观上很难把代码写好。

对于上述现状，就我个人感觉，不少项目代码质量管理上可能有意或者潜意识地采取这种做法：即不要玩什么花活，把变量的命名保证望文生义、固定的常量统一抽取等等，简而言之，保证基本的代码规范、保证鲁棒性（是叫这个？）即可。这样即便需求变化，每次修改成本也不大；看起来挺好，但时间一长再加上研发人员水平参差不齐，慢慢也就失控成屎山了，所以一般业务迭代上会加上研发人员不定期重构优化的技术需求，以一定程度上缓解屎山越来越大的情况。确实是个很符合实际的举措，从商业角度十分正确，但怎么说呢，从大环境上考虑，真给我一种浓浓的囚徒困境的感觉啊。。。

## 二、为什么真正理解需求对代码设计那么重要？

我们很容易就能发现，一般框架、工具类的代码都是很优雅的，当然一般写这种基础设施的人水平都很高这是一方面，但另一方面比如我现在写一个json解析器时，我其实不止是一个工具的开发人员，我其实已经隐含着我已经很了解一个json解析器应该具备什么功能这一点，并且我很清楚未来功能上基本不会有变化；所以我其实是作为我很了解一个json解析器所应该提供的功能的角色进行研发，我几乎不用考虑未来的变化，定义好对外提供的功能接口，对于内部的设计我有种非常高的自由性，所以我在开发的过程前或中可以不断思考怎么设计让代码更精简、性能更好，慢慢就会逐渐摸索出对于当前自己的最好的一套设计（当然未来你也可能发现有更好的方式）

实际需求开发中，我遇到的主子列表设计可能更符合这种场景，因为既满足业务相对固定（也不算太复杂，一个列表能有啥大变化？）、又满足通用性（作为一种模式，其他研发照着我抄就行，节省大家时间以去做更重要的事情）

```
简单描述下吧：一个订单底下会关联多个子单，每个子单对应用户所买的商品信息（1：*），那么现在我进到列表，我能直接看到订单，也能看到订单下的子单（比如一个订单下有3个子单)，如果一个订单的子单过多超过5条，那就只展示5条，下面有下拉，点击可以展示之后的子单。
前端传一个query作为搜索参数，这个query是作为搜索的参数，我是把它作为充血模型考虑的（按照DDD的思想，他是有行为的，好处在于更易理解，而且也避免把方法全堆到service里的窘境），那么我把只有他会使用的固定的常量作为接口变量封装到类里，它也提供了一些方法用于判断这些字段是安装精确还是模糊搜索。
然后搜索条件大概可以分为两类，一个是主单维度的搜索，一个是子单维度的搜索，建造一个条件factory，用query分别构造出主、子条件，为什么要分成两类呢？因为如果条件如果没有子表相关的条件，那么构造主表相关的sql就可以减少连表情况，提升查询效率
根据是否查询子单调用页面返回factory的不同方法，先查主单（这里可通过先查id连自己减少分页开销），根据主单id和子条件group by差主单对应的子单数，这样子单分为两种，数量>5的使用聚合函数只查前5条，小于5的直接查。这样就避免了循环调用sql的开销，子单搜索条件通过主单id批量查，命中索引，很快
然后再factory内转换数据。
```

上述情况，就是建立在我们真正理解需求的前提下的设计。那么，如果在没充分理解需求或者没有预料到需求的变化，而盲目的使用设计模式会带来什么后果呢？

```
也是实际碰到的场景，当时我在做国外物流对接，这里是对接获取物流单号、获取面单接口，正常的接口都是获取物流单号拿到3方的物流单号，然后根据物流单号去查面单，但三方物流没有统一的标准，各自实现的千变万化不按套路啊，这个物流面单需要用到单号和渠道，渠道是获取单号用的，这是两个方法，然后又使用了factory和adapter包装了好几层，我根本就没法修改获取面单的参数，因为继承了统一的接口，我总不能把几百个物流都改一遍吧，而且参数也根本传不到这个接口，因为中间有很多次嵌套，所以要怎么办呢？我只能采取邪道的做法，物流实体里封装一个ThreadLocal，因为唯一能保证的是这两个方法的调用都在一个线程里，获取单号把渠道存到线程副本里，获取运单取出再移除。
```

说实话，其实人家设计的挺好的，但他没考虑到物流三方的接口套路太深，这就导致当需求发生变化时，他封装的越“好”，我要修改就越麻烦，甚至只能通过各种奇怪甚至诡异的方式小心地避开这些条条框框进行修改。

所以，由上可见：**如果要设计出真正好的代码，我们必须去真正理解需求。**我们要明白我们面临的需求到底是要解决什么问题？这个需求能否真正解决这个问题？这个需求未来有哪些地方可能会有变化、那些地方不会变等等...我们必须要和产品、客户去沟通清楚，要不然你认为不会变的地方结果最后真的发生了变化（等着加班吧，少年），或者你认为会变的地方结果万年不变（白白设计了一套，徒增复杂度），这些欠下的债，早晚会有人还。

## 三、那么如何去理解需求呢？

其实这个说简单也简单，说复杂也复杂：要主动地、深入地、全面地思考需求，要**主动**跟产品或者客户沟通需求，明确是否合理、如果合理的话，要明确这个需求未来的大致有哪些方向上的变化，尽可能明确**变化**与**不变（说实话，产品说不变的地方，不要太相信，最好仔细考虑考虑）**的点。

上面搞清楚之后，不断给自己提出问题、解决问题，设计相应的模型，针对不变的地方进行封装，针对可能变化的地方进行扩展，要不断仔细思考满足模型的相对精简的设计，并且也要注意避免过度设计，要保留一定程度上的鲁棒性（毕竟谁都不能预测未来变化），然后你会发现你的设计可能就是某种设计模式，也可能不是（那就说明你自己创造了新的设计模式），所以说设计模式不关键，关键在于你的理解、你的思考。

感觉是不是说的有点玄？举个例子吧

```
之前有个需求采购建议，就是要针对订单的销量情况和库存情况，对货品+仓库维度计算出相应的活跃度（如爆款、稳定之类的），再根据活跃度找到对应的策略，再根据系统设置的相关公式，生成对应的采购建议数据；麻烦的点在于活跃度和策略自由性很高，用户可以启用、也可以禁用，公式也可以调整，并且这些调整都要触发相关数据的更新。

拿到需求文档后，我首先得思考这个需求是否合理，这个需求生成的这些数据要做什么用（作为采购单、采购计划的来源、客户也可以查看数据便于分析），我慢慢就发现这个活跃度很关键，产品提供了几个固定的活跃度，统一启用或者禁用，那么就要明确变与不变，比如这个活跃度优先级未来是否会支持用户自己设置？未来是否会加活跃度？梳理出相关的问题，跟产品沟通...
需求都明确后，开始设计，不同活跃度具有共同的行为，是否可以抽取个活跃度模板？活跃度和策略要怎么封装，各种量计算方法是否可以统一抽取到某个helper类中？为了提高效率，是否可以定制化各种操作的更新方式使其操纵数据最小等待...
```

你看经过不断地提出问题、解决问题，不断地思考，我们就会慢慢摸索出一个复杂需求的较优代码结构，然后在实际开发过程中也可以不断调整优化。

## 四、我对常用设计模式的理解（todo 很久之前写的，有时间改改）

设计模式大概分为创建型、结构型、行为型，后二者更有趣些。

### 1.代理模式

主要是在不修改原有类的前提下，增强该类某些方法的功能，比如原有个调三方接口的工具，我增加一个统计调用时间的功能，就可以使用代理模式，就相当于用代理类包了一层。

代理分为静态代理和动态代理，静态代理偏向于设计模式层面，需要为每个类都建立代理类

动态代理则是动态生成代理类，一般使用java自带的代理功能（只能代理接口）和cglib（具体可看我写的cglib学习）

我个人觉得尴尬的地方在于有时引入代理模式不一定使更简单，反而使其变得更复杂了，有时2行代码就能解决的问题，用个代理还多个类，而且代理类也不好复用，设计一个抽象的"代理模板"也没什么必要，因为代理基本上都是个性化的需求，别告诉我你还要再抽象个代理策略（把个性化的需求弄成策略那种），这就是典型的简单问题复杂化；想来想去可能写lib会用到多一些，平常也可以用，但必要性不是很大。

### 2.装饰者模式

代理模式的弊端在于只能增强一次方法，如果需要给方法增强多个功能，甚至各个功能的顺序可以自由调整，代理就不适用了，这时候就应该用装饰者模式，这个模式其实很有意思，而且比代理模式更实用一些。

大概结构：

一般需要建一个抽象装饰者继承原类，并且内部有个指向原类的引用，和一个或多个的装饰方法，多个装饰者需要继承该抽象装饰者，调用父类的构造函数和装饰方法，大概下面代码的意思，最典型的应用是java各种输入输出流（ps：我一直觉得流这东西用起来太”底层“了，不像一个高级工具）

实际使用大概是这种方式

```java
new Test1Wrapper(new Test2Wrapper(new Test3Wrapper())).executeTask(task)
```

装饰者简单结构

```java
public abstract class AbstractTaskMQConsumerWrapper extends AbstractTaskMQConsumer {
    private AbstractTaskMQConsumer wrapper;

    public AbstractTaskMQConsumerWrapper(AbstractTaskMQConsumer wrapper) {
        this.wrapper = wrapper;
    }

    @Override
    public void executeTask(TaskPojo task) {
        wrapper.executeTask(task);
    }
}
@Slf4j
public class TestWrapper extends AbstractTaskMQConsumerWrapper {

    public TestWrapper(AbstractTaskMQConsumer wrapper) {
        super(wrapper);
    }

    @Override
    public void executeTask(TaskPojo task) {
        final long beginTime = System.currentTimeMillis();
        super.executeTask(task);
        final long endTime = System.currentTimeMillis();
        log.info("consumer总耗时:{}ms", (endTime - beginTime));
    }
}
```

### 3.模板模式

这估计是我使用了最多的设计模式吧，基本上一些逻辑结构固定，但具体细节不同的都可以使用这种模式，

以我最近的使用举例，有个mq任务消费者，用来处理各种task，不同task处理逻辑不同，但前置的mq接受消息，切换数据库，设置MDC，打印日志等都相同，就很适合将任务处理方法弄成抽象方法，做成模板模式；

还有上家公司弄的数据抽取，抽取的大体逻辑都是固定的，只是要抽取的数据不同，存的表不同。

最近也碰到了计算及配置商品活跃度的也可以使用类似模板模式（**虽然严格来说我觉得更像是抽象继承以及策略**）

以活跃度枚举为key，活跃度数据及策略数据为value，对活跃度的行为进行抽象。

```java
//抽象活跃度暂时有4种类型
public abstract class BaseSales {
    /**
     * 获取活跃度类型
     *
     * @return
     */
    public abstract SkuActivationType getType();

    /**
     * json -> 具体活跃度
     *
     * @param json
     */
    public abstract void transform(JSONObject json);

    /**
     * 判断sku活跃度前校验活跃度数据是否合法
     */
    public abstract void checkSales();

    /**
     * 是否符合活跃度
     *
     * @param baseData
     * @return
     */
    public abstract boolean isConformActivation(PurchaseAdviceStatisticsBaseData baseData);
}

//构造活跃度map
private Map<SkuActivationType, ActivationStrategy> buildActivationStrategyMap() {
        Map<SkuActivationType, ActivationStrategy> activationStrategyMap = new HashMap<>();
        PurchaseStrategyPojo defaultStrategyPojo = purchaseStrategyDao.getDefaultEnableStrategy();
        for (SkuActivationType type : SkuActivationType.values()) {
            final BaseSales sales = type.createSales(purchaseSkuActivationDao);
            sales.checkSales();
            final PurchaseStrategyPojo strategy = getStrategy(type, defaultStrategyPojo);
            activationStrategyMap.put(type, new ActivationStrategy(sales, strategy));
        }
        return activationStrategyMap;
    }

private PurchaseStrategyPojo getStrategy(SkuActivationType type, PurchaseStrategyPojo defaultStrategyPojo) {
        PurchaseStrategyPojo strategyPojo = purchaseStrategyDao.getEnableStrategyByType(type);
        return Objects.nonNull(strategyPojo) ? strategyPojo : defaultStrategyPojo;
    }

//计算活跃度
private SkuActivationType calculateSkuActivation(PurchaseAdviceStatisticsBaseData baseData, Map<SkuActivationType, ActivationStrategy> activationStrategyMap) {
        final List<SkuActivationType> skuActivationTypes = Stream.of(SkuActivationType.values()).sorted(Comparator.comparingInt(SkuActivationType::getPriority)).collect(Collectors.toList());
        for (SkuActivationType type : skuActivationTypes) {
            final boolean conformActivation = activationStrategyMap.get(type).getSales().isConformActivation(baseData);
            if (conformActivation) {
                return type;
            }
        }
        return SkuActivationType.STABLE_SALES;
    }
```

活跃度枚举

```java
/**
 * 采购建议SKU活跃度
 *
 */
public enum SkuActivationType {
    /**
     * 爆款
     */
    POPULAR_SALES(BYTE_ONE, PopularSales.class, 1),
    /**
     * 滞销款
     */
    UN_SALES(BYTE_TWO, UnSales.class, 2),
    /**
     * 新品
     */
    NEW_SALES(BYTE_THREE, NewSales.class, 3),
    /**
     * 稳定款
     */
    STABLE_SALES(BYTE_FOUR, StableSales.class, 4);

    private Byte type;
    private Class<? extends BaseSales> salesClass;
    /**
     * 优先级，越小越优先
     */
    private int priority;

    SkuActivationType(Byte type, Class<? extends BaseSales> salesClass, int priority) {
        this.type = type;
        this.salesClass = salesClass;
        this.priority = priority;
    }

    public Byte getType() {
        return type;
    }

    public Class<? extends BaseSales> getSalesClass() {
        return salesClass;
    }

    public int getPriority() {
        return priority;
    }

    public BaseSales createSales(PurchaseSkuActivationDao purchaseSkuActivationDao) {
        try {
            final BaseSales sales = this.salesClass.newInstance();
            final JSON value = purchaseSkuActivationDao.getPurchaseSkuActivationValue(this);
            JSONObject json = null;
            if (Objects.nonNull(value)) {
                json = JSONObject.parseObject(value.data());
            }
            sales.transform(json);
            return sales;

        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        throw new ApiCommException("构建SKU活跃度数据异常");
    }

    public static boolean isStableSales(SkuActivationType type) {
        return STABLE_SALES == type;
    }

    public static SkuActivationType getSkuActivationType(Byte code) {
        for (SkuActivationType skuActivationType : values()) {
            if (skuActivationType.getType().equals(code)) {
                return skuActivationType;
            }
        }
        return null;
    }
}
```



